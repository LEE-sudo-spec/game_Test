<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>갤럭시 슈터</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            text-align: center;
        }
        
        canvas {
            border: 2px solid #0ff;
            box-shadow: 0 0 20px #0ff;
            background: linear-gradient(to bottom, #000 0%, #0a0a2e 100%);
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0ff;
            font-size: 18px;
            text-shadow: 0 0 10px #0ff;
            z-index: 10;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0;
            font-size: 36px;
            text-shadow: 0 0 20px #ff0;
            display: none;
            text-align: center;
            z-index: 20;
        }
        
        #instructions {
            color: #0ff;
            margin-top: 20px;
            font-size: 14px;
            text-shadow: 0 0 5px #0ff;
        }
        
        .glow {
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div>SCORE: <span id="score">0</span></div>
            <div>LIVES: <span id="lives">3</span></div>
            <div>WAVE: <span id="wave">1</span></div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="gameOver">
            <div>GAME OVER</div>
            <div style="font-size: 20px; margin-top: 10px;">Final Score: <span id="finalScore">0</span></div>
            <div style="font-size: 16px; margin-top: 20px;">Press SPACE to restart</div>
        </div>
        <div id="instructions">
            <div>← → Arrow Keys: Move | SPACE: Fire | P: Pause</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 600;

        // Game state
        let gameRunning = true;
        let gamePaused = false;
        let score = 0;
        let lives = 3;
        let wave = 1;
        let stars = [];
        let particles = [];
        let powerUps = [];

        // Player
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 60,
            width: 40,
            height: 40,
            speed: 7,
            bullets: [],
            fireRate: 0,
            maxFireRate: 5
        };

        // Enemies
        let enemies = [];
        let enemyBullets = [];

        // Controls
        const keys = {};

        // Star background
        class Star {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2;
                this.speed = Math.random() * 2 + 0.5;
                this.brightness = Math.random();
            }

            update() {
                this.y += this.speed;
                if (this.y > canvas.height) {
                    this.y = 0;
                    this.x = Math.random() * canvas.width;
                }
                this.brightness = Math.sin(Date.now() * 0.001 + this.x) * 0.5 + 0.5;
            }

            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness})`;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }
        }

        // Particle effect
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.size = Math.random() * 3 + 1;
                this.life = 1;
                this.color = color;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
                this.size *= 0.98;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.restore();
            }
        }

        // Enemy class
        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = type === 'boss' ? 60 : 30;
                this.height = type === 'boss' ? 60 : 30;
                this.speed = type === 'boss' ? 1 : 2;
                this.health = type === 'boss' ? 10 : 1;
                this.points = type === 'boss' ? 500 : 100;
                this.fireRate = 0;
                this.maxFireRate = type === 'boss' ? 30 : 60;
                this.movePattern = Math.random() > 0.5 ? 'sine' : 'straight';
                this.time = 0;
            }

            update() {
                this.time++;
                if (this.movePattern === 'sine') {
                    this.x += Math.sin(this.time * 0.05) * 2;
                }
                this.y += this.speed;

                // Fire bullets
                this.fireRate++;
                if (this.fireRate >= this.maxFireRate) {
                    this.fireRate = 0;
                    enemyBullets.push({
                        x: this.x + this.width / 2,
                        y: this.y + this.height,
                        speed: 4,
                        width: 4,
                        height: 10
                    });
                }
            }

            draw() {
                ctx.fillStyle = this.type === 'boss' ? '#f0f' : '#f00';
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.type === 'boss' ? '#f0f' : '#f00';
                
                // Draw enemy ship
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.lineTo(this.x + this.width / 2, this.y + this.height * 0.7);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }

            takeDamage() {
                this.health--;
                for (let i = 0; i < 5; i++) {
                    particles.push(new Particle(
                        this.x + this.width / 2,
                        this.y + this.height / 2,
                        this.type === 'boss' ? '#f0f' : '#f00'
                    ));
                }
                return this.health <= 0;
            }
        }

        // Initialize stars
        for (let i = 0; i < 100; i++) {
            stars.push(new Star());
        }

        // Spawn enemies
        function spawnWave() {
            enemies = [];
            const enemyCount = Math.min(5 + wave * 2, 20);
            
            for (let i = 0; i < enemyCount; i++) {
                const x = Math.random() * (canvas.width - 30);
                const y = -50 - (i * 40);
                enemies.push(new Enemy(x, y, 'normal'));
            }
            
            // Add boss every 5 waves
            if (wave % 5 === 0) {
                enemies.push(new Enemy(canvas.width / 2 - 30, -100, 'boss'));
            }
        }

        // Draw player
        function drawPlayer() {
            ctx.fillStyle = '#0ff';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#0ff';
            
            // Draw ship
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y);
            ctx.lineTo(player.x, player.y + player.height);
            ctx.lineTo(player.x + player.width / 2, player.y + player.height * 0.7);
            ctx.lineTo(player.x + player.width, player.y + player.height);
            ctx.closePath();
            ctx.fill();
            
            // Draw engine flame
            ctx.fillStyle = '#ff0';
            ctx.shadowColor = '#ff0';
            const flameSize = Math.random() * 10 + 5;
            ctx.fillRect(player.x + player.width / 2 - 2, player.y + player.height, 4, flameSize);
            
            ctx.shadowBlur = 0;
        }

        // Update game
        function update() {
            if (!gameRunning || gamePaused) return;

            // Update stars
            stars.forEach(star => star.update());

            // Update particles
            particles = particles.filter(particle => {
                particle.update();
                return particle.life > 0;
            });

            // Player movement
            if (keys['ArrowLeft'] && player.x > 0) {
                player.x -= player.speed;
            }
            if (keys['ArrowRight'] && player.x < canvas.width - player.width) {
                player.x += player.speed;
            }

            // Player shooting
            player.fireRate++;
            if (keys[' '] && player.fireRate >= player.maxFireRate) {
                player.fireRate = 0;
                player.bullets.push({
                    x: player.x + player.width / 2 - 2,
                    y: player.y,
                    speed: 10,
                    width: 4,
                    height: 10
                });
            }

            // Update player bullets
            player.bullets = player.bullets.filter(bullet => {
                bullet.y -= bullet.speed;
                return bullet.y > -10;
            });

            // Update enemies
            enemies = enemies.filter(enemy => {
                enemy.update();
                return enemy.y < canvas.height + 50;
            });

            // Update enemy bullets
            enemyBullets = enemyBullets.filter(bullet => {
                bullet.y += bullet.speed;
                return bullet.y < canvas.height + 10;
            });

            // Check collisions - player bullets vs enemies
            player.bullets.forEach((bullet, bulletIndex) => {
                enemies.forEach((enemy, enemyIndex) => {
                    if (bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y) {
                        
                        if (enemy.takeDamage()) {
                            score += enemy.points;
                            enemies.splice(enemyIndex, 1);
                            
                            // Big explosion for destroyed enemy
                            for (let i = 0; i < 20; i++) {
                                particles.push(new Particle(
                                    enemy.x + enemy.width / 2,
                                    enemy.y + enemy.height / 2,
                                    enemy.type === 'boss' ? '#f0f' : '#ff0'
                                ));
                            }
                        }
                        player.bullets.splice(bulletIndex, 1);
                    }
                });
            });

            // Check collisions - enemy bullets vs player
            enemyBullets.forEach((bullet, index) => {
                if (bullet.x < player.x + player.width &&
                    bullet.x + bullet.width > player.x &&
                    bullet.y < player.y + player.height &&
                    bullet.y + bullet.height > player.y) {
                    
                    enemyBullets.splice(index, 1);
                    lives--;
                    
                    // Player hit effect
                    for (let i = 0; i < 15; i++) {
                        particles.push(new Particle(
                            player.x + player.width / 2,
                            player.y + player.height / 2,
                            '#0ff'
                        ));
                    }
                    
                    if (lives <= 0) {
                        gameOver();
                    }
                }
            });

            // Check collisions - enemies vs player
            enemies.forEach((enemy, index) => {
                if (enemy.x < player.x + player.width &&
                    enemy.x + enemy.width > player.x &&
                    enemy.y < player.y + player.height &&
                    enemy.y + enemy.height > player.y) {
                    
                    enemies.splice(index, 1);
                    lives--;
                    
                    // Collision effect
                    for (let i = 0; i < 25; i++) {
                        particles.push(new Particle(
                            enemy.x + enemy.width / 2,
                            enemy.y + enemy.height / 2,
                            '#ff0'
                        ));
                    }
                    
                    if (lives <= 0) {
                        gameOver();
                    }
                }
            });

            // Check for wave completion
            if (enemies.length === 0) {
                wave++;
                spawnWave();
            }

            // Update UI
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('wave').textContent = wave;
        }

        // Draw everything
        function draw() {
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            stars.forEach(star => star.draw());

            // Draw particles
            particles.forEach(particle => particle.draw());

            // Draw player
            if (gameRunning) {
                drawPlayer();
            }

            // Draw player bullets
            ctx.fillStyle = '#0ff';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#0ff';
            player.bullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });

            // Draw enemies
            enemies.forEach(enemy => enemy.draw());

            // Draw enemy bullets
            ctx.fillStyle = '#f00';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#f00';
            enemyBullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });

            ctx.shadowBlur = 0;

            // Draw pause text
            if (gamePaused) {
                ctx.fillStyle = '#ff0';
                ctx.font = '48px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
                ctx.font = '16px Courier New';
                ctx.fillText('Press P to continue', canvas.width / 2, canvas.height / 2 + 40);
            }
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }

        // Restart game
        function restart() {
            gameRunning = true;
            score = 0;
            lives = 3;
            wave = 1;
            player.x = canvas.width / 2;
            player.y = canvas.height - 60;
            player.bullets = [];
            enemies = [];
            enemyBullets = [];
            particles = [];
            document.getElementById('gameOver').style.display = 'none';
            spawnWave();
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === 'p' || e.key === 'P') {
                gamePaused = !gamePaused;
            }
            
            if (e.key === ' ' && !gameRunning) {
                restart();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Start game
        spawnWave();
        gameLoop();
    </script>
</body>
</html>
